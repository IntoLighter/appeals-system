package com.intolighter.appealssystem.repositories;

import com.intolighter.appealssystem.errors.exceptions.UserNotFoundException;
import com.intolighter.appealssystem.models.ERole;
import com.intolighter.appealssystem.models.User;
import lombok.val;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Objects;
import java.util.Optional;

@Component
public class UserRepository extends RepositoryUtils {

    public UserRepository(JdbcTemplate jdbcTemplate) {
        super(jdbcTemplate, "users");
    }

    private static User mapToUser(ResultSet rs, int rowNum) throws SQLException {
        return new User(
                rs.getLong("id"),
                rs.getString("first_name"),
                rs.getString("phone_number"),
                rs.getString("email"),
                rs.getString("password"),
                rs.getBoolean("enabled"));
    }

    public User save(User user) {
        jdbcTemplate.update(
                "INSERT INTO users (first_name, last_name, phone_number, password, email, enabled) VALUES (?, ?, ?, ?, ?, ?)",
                user.getFirstName(), user.getLastName(), user.getPhoneNumber(), user.getPassword(), user.getEmail(), user.isEnabled());

        for (val role : user.getRoles())
            jdbcTemplate.update(
                    "INSERT INTO user_roles VALUES ((SELECT id FROM users WHERE email = ?), ?)",
                    user.getEmail(), role.name());

        return findByEmail(user.getEmail())
                .orElseThrow(() -> new UserNotFoundException(
                        "User with email: '" + user.getEmail() + "' not found after saving"));
    }

    public void updateEnabled(User user) {
        jdbcTemplate.update("UPDATE users SET enabled = true WHERE id = ?", user.getId());
    }

    public Optional<User> findByEmail(String email) {
        return Optional.ofNullable(getUserByParameter("email", email));
    }

    public Optional<User> findById(long id) {
        return Optional.ofNullable(getUserByParameter("id", id));
    }

    public boolean existsByPhoneNumber(String phoneNumber) {
        return checkForExistence("phone_number", phoneNumber);
    }

    public boolean existsByEmail(String email) {
        return checkForExistence("email", email);
    }

    private <T> User getUserByParameter(String paramName, T paramValue) {
        val user = jdbcTemplate.queryForObject(
                String.format("SELECT * FROM users WHERE %s = %s", paramName, "'" + paramValue + "'"),
                UserRepository::mapToUser);

        val role = jdbcTemplate.queryForObject("SELECT role FROM user_roles WHERE user_id = ?",
                String.class, Objects.requireNonNull(user).getId());

        switch (Objects.requireNonNull(role)) {
            case "ROLE_USER":
                user.getRoles().add(ERole.ROLE_USER);
                break;
            case "ROLE_GOVERNMENT":
                user.getRoles().add(ERole.ROLE_GOVERNMENT);
                break;
            default:
                throw new UserNotFoundException("User role '" + role + "' is not found");
        }

        return user;
    }

    @PostConstruct
    private void createDb() {
        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS users(" +
                "id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY," +
                "email varchar," +
                "password varchar," +
                "phone_number varchar," +
                "enabled bool," +
                "first_name varchar," +
                "last_name varchar" +
                ")");

        jdbcTemplate.execute("CREATE TABLE IF NOT EXISTS user_roles(" +
                "user_id bigint not null " +
                "constraint fkhfh9dx7w3ubf1co1vdev94g3f " +
                "references users on delete cascade," +
                "role varchar)");
    }
}
